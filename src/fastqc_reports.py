# Import necessary libraries:
import sys
import csv
import os
import subprocess
import zipfile
import getopt

inputFolder=""
outputFolder=""
outputfile=""
isZip=False


class Error (Exception):
        """Base error for this module"""
        pass

class InputError (Error):
        """ Exceptions raised when input was wrong
                Attributes:
                        msg -- explanation of the error
        """
        def __init__(self, msg):
                self.msg = msg
                pass

class TypeError (Error):
        """ Exception if file types are wrong
                Attributes:
                        msg -- explanation
        """
        def __init__ (self, msg):
                self.msg = msg  
                
class ZipContentError (Error):
        """ Error when no files are finding in the report """
        def __init__ (self, msg):
                self.msg = msg
                              

def input_handler (argv):
        inputFolder=""
        outputFolder=""
        outputFile=""
        isZip=False
        
        def Usage ():
                errorMSG="Usage:\nfastqc_reports.py -i <inputFolder> -o <outputFolder> -f <outputFileName>\nfastqc_report.py -h" \
                                 " for help"
                print (errorMSG)
                sys.exit()

        try:
                opts, rest = getopt.getopt (argv, 'hzo:f:i:', ["help", "zip", "outputFolder=", "filename=", "inputFolder="])
        except getopt.GetoptError:
                Usage()

        for opt, arg in opts:
                if opt in ("-h", "--help"):
                        print ("\n\tCombine reports from fastqc to a single .csv table")
                        print ("Usage: \tfastqc_reports.py -i <inputFolder> -o <outputFolder> -f <outputFileName>")
                        print ("Or: \tfastqc_reports.py --inputFolder <inputFolder> --outputFolder <outputFolder> --filename <outputFileName>")
                        print ("Arguments: ")
                        print ("\t-z (zip)an optional argument, set if zip archives should be scanned instead of folders")
                        print ("\t-i (--inputFolder) a location of folders made by fastqc package. If not specified, use a current folder")
                        print ("\t-o (--outputFolder) A specified location for the output file. If not specified, the default file report will be created in the input folder")
                        print ("\t-f (--filename) A name of the report file with extention (.csv). Default name is fastqc_report.csv")
                        sys.exit(2)

                elif opt in ("-z", "--zip"):
                        isZip=True

                elif opt in ("-i", "--inputFolder"):
                        path = os.path.join(os.getcwd(), arg)
                        if os.path.isdir (path) == True:
                                inputFolder = path
                        else: raise InputError (path+ " is not a directory")

                elif opt in ("-o", "--outputFolder"):
                        outputFolder = arg

                elif opt in ("-f", "--filename"):
                        if arg[-3:] == 'csv':
                                outputFile = arg
                        
                        else: raise InputError ( "Wrong file type was given. Read help")
                        #print ("Arg: ", arg, " OUT: ", outputFile)

        if len (inputFolder) == 0: inputFolder = os.getcwd()
        if len(outputFolder) == 0: outputFolder = inputFolder
        if len(outputFile) == 0: outputFile = "fastqc_report.csv"

        return {'i':inputFolder, 'o':outputFolder, 'f':outputFile, 'z':isZip}

def get_file_list (path, isZip):
        """Return pathes where data should be extracted"""
        files_path = []
        # Get list of '_fastqc.zip' files generated by FastQC:
        fileList = os.listdir(path)
        if (len(fileList) == 0) :raise TypeError ("Input folder is empty")
        
        if (isZip):
                for f in fileList:
                        if f.endswith ("_fastqc.zip"):
                                files_path.append(os.path.join(path, f))
                if len(files_path) == 0:
                        raise TypeError ("No .zip files were found")
        else:
                for f in fileList:
                        if f.endswith ("_fastqc") and os.path.isdir(os.path.join (path, f)):
                                files_path.append(os.path.join(path, f))
                if len(files_path) == 0:
                        raise TypeError ("No correct folders were found. See -help")
        return files_path
        
def parse_fastqc_summary (fileConnection, isZip):
        """ Should parse file and return data """
        parse_result = {}
                  
        for line in fileConnection:
                if isZip: line=line.decode('utf-8')
                par = line.split("\t")
                score = par[0]
                module = par [1]
                parse_result[module] = score                        
                        
        return parse_result
        
def get_info_from_zip (zipFilePath):
        """ Open zip file and send report file to the next function """

        archive = zipfile.ZipFile(zipFilePath, 'r')
        members = archive.namelist()
        # find 'summary.txt' in members
        fname = [member for member in members if 'summary.txt' in member][0] 
        # Open text file
        data = archive.open(fname)
                
        # Send file to parcer
        parsed_data = parse_fastqc_summary (data, True)
        
        # Close connection
        data.close()
        archive.close()
        
        return parsed_data 
        
def combine_reports (dir, isZip):
        """ Give a dictionary with fileNames as keys and dictionary with fastqc results as value """
        combinedResults = {}
        
        for f in dir:
                data = {}
                if isZip:
                        data = get_info_from_zip (f)
                else: 
                        path = os.path.join(f, "summary.txt")     
                        sum = open (path, 'r')                        
                        data = parse_fastqc_summary (sum, False)
                        sum.close()
                        
                reportName = os.path.basename(f).split("_fastqc")[0]
                combinedResults[reportName] = data
        return (combinedResults)
        
def report_to_csv (dic, path, filename):
        """ Print out dictionary information into csv file """
        fileLoc = os.path.join (path, filename)
        f = open (fileLoc, 'w', newline='')
        writer = csv.writer(f)
        
        # Create a header
        tests = (list ((next (iter (dic.values()))).keys()))
        # Sort them by name, so all tests will be the same
        tests.sort()
        tests = ["Name"] + tests

        writer.writerow (tests)
        for qc in dic:
                values = list(dic[qc].values())
                values.sort ()
                writer.writerow ([qc] + values)
        f.close()
        
        
def main (argv):
        # Proceed options've been passed through the function call
        input = input_handler (argv)
        
        # Assign parameters
        inputFolder=input['i']
        outputFolder=input['o']
        outputFile=input['f']
        isZip=['z']
        
        file_list = get_file_list (inputFolder, isZip)
        results = combine_reports (file_list, isZip)
        
        # Write scores out to a CSV file:
        fileLoc = os.path.join(os.path.dirname(outputFolder), outputFile)
        report_to_csv (results, outputFolder, outputFile)

if __name__== "__main__":
        main (sys.argv[1:])